/**
 * Type definitions for @mattiasbuelens/web-streams-polyfill v0.3.1
 */
// FILE GENERATED BY `rollup-plugin-dts@0.12.0`
// https://github.com/Swatinem/rollup-plugin-dts

declare type QueuingStrategySizeCallback<T = any> = (chunk: T) => number;
interface QueuingStrategy<T = any> {
    highWaterMark?: number;
    size?: QueuingStrategySizeCallback<T>;
}

declare type WritableStreamDefaultControllerStartCallback = (controller: WritableStreamDefaultController) => void | PromiseLike<void>;
declare type WritableStreamDefaultControllerWriteCallback<W> = (chunk: W, controller: WritableStreamDefaultController) => void | PromiseLike<void>;
declare type WritableStreamDefaultControllerCloseCallback = () => void | PromiseLike<void>;
declare type WritableStreamErrorCallback = (reason: any) => void | PromiseLike<void>;
interface UnderlyingSink<W = any> {
    start?: WritableStreamDefaultControllerStartCallback;
    write?: WritableStreamDefaultControllerWriteCallback<W>;
    close?: WritableStreamDefaultControllerCloseCallback;
    abort?: WritableStreamErrorCallback;
    type?: undefined;
}
declare class WritableStream<W = any> {
    constructor(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>);
    readonly locked: boolean;
    abort(reason: any): Promise<void>;
    getWriter(): WritableStreamDefaultWriter<W>;
}
declare type WritableStreamDefaultWriterType<W> = WritableStreamDefaultWriter<W>;
declare class WritableStreamDefaultWriter<W> {
    constructor(stream: WritableStream<W>);
    readonly closed: Promise<void>;
    readonly desiredSize: number | null;
    readonly ready: Promise<void>;
    abort(reason: any): Promise<void>;
    close(): Promise<void>;
    releaseLock(): void;
    write(chunk: W): Promise<void>;
}
declare type WritableStreamDefaultControllerType = WritableStreamDefaultController<any>;
declare class WritableStreamDefaultController<W = any> {
    error(e: any): void;
}

declare type ReadableByteStream = ReadableStream<Uint8Array>;
declare type ReadableStreamDefaultControllerCallback<R> = (controller: ReadableStreamDefaultController<R>) => void | PromiseLike<void>;
declare type ReadableByteStreamControllerCallback = (controller: ReadableByteStreamController) => void | PromiseLike<void>;
declare type ReadableStreamErrorCallback = (reason: any) => void | PromiseLike<void>;
interface UnderlyingSource<R = any> {
    start?: ReadableStreamDefaultControllerCallback<R>;
    pull?: ReadableStreamDefaultControllerCallback<R>;
    cancel?: ReadableStreamErrorCallback;
    type?: undefined;
}
interface UnderlyingByteSource {
    start?: ReadableByteStreamControllerCallback;
    pull?: ReadableByteStreamControllerCallback;
    cancel?: ReadableStreamErrorCallback;
    type: 'bytes';
    autoAllocateChunkSize?: number;
}
interface PipeOptions {
    preventAbort?: boolean;
    preventCancel?: boolean;
    preventClose?: boolean;
    signal?: AbortSignal;
}
interface ReadResult<T = any> {
    done: boolean;
    value: T;
}
declare class ReadableStream<R = any> {
    constructor(underlyingSource: UnderlyingByteSource, strategy?: {
        highWaterMark?: number;
        size?: undefined;
    });
    constructor(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>);
    readonly locked: boolean;
    cancel(reason: any): Promise<void>;
    getReader({ mode }: {
        mode: 'byob';
    }): ReadableStreamBYOBReader;
    getReader(): ReadableStreamDefaultReader<R>;
    pipeThrough<T>({ writable, readable }: {
        writable: WritableStream<R>;
        readable: ReadableStream<T>;
    }, { preventClose, preventAbort, preventCancel, signal }?: PipeOptions): ReadableStream<T>;
    pipeTo(dest: WritableStream<R>, { preventClose, preventAbort, preventCancel, signal }?: PipeOptions): Promise<void>;
    tee(): [ReadableStream<R>, ReadableStream<R>];
}
declare type ReadableStreamDefaultReaderType<R> = ReadableStreamDefaultReader<R>;
declare class ReadableStreamDefaultReader<R> {
    constructor(stream: ReadableStream<R>);
    readonly closed: Promise<void>;
    cancel(reason: any): Promise<void>;
    read(): Promise<ReadResult<R>>;
    releaseLock(): void;
}
declare type ReadableStreamBYOBReaderType = ReadableStreamBYOBReader;
declare class ReadableStreamBYOBReader {
    constructor(stream: ReadableByteStream);
    readonly closed: Promise<void>;
    cancel(reason: any): Promise<void>;
    read<T extends ArrayBufferView>(view: T): Promise<ReadResult<T>>;
    releaseLock(): void;
}
declare type ReadableStreamDefaultControllerType<R> = ReadableStreamDefaultController<R>;
declare class ReadableStreamDefaultController<R> {
    readonly desiredSize: number | null;
    close(): void;
    enqueue(chunk: R): void;
    error(e: any): void;
}
declare type ReadableStreamBYOBRequestType = ReadableStreamBYOBRequest;
declare class ReadableStreamBYOBRequest {
    readonly view: ArrayBufferView;
    respond(bytesWritten: number): void;
    respondWithNewView(view: ArrayBufferView): void;
}
declare type ReadableByteStreamControllerType = ReadableByteStreamController;
declare class ReadableByteStreamController {
    readonly byobRequest: ReadableStreamBYOBRequest | undefined;
    readonly desiredSize: number | null;
    close(): void;
    enqueue(chunk: ArrayBufferView): void;
    error(e: any): void;
}

declare class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {
    readonly highWaterMark: number;
    constructor({ highWaterMark }: {
        highWaterMark: number;
    });
    size(chunk: ArrayBufferView): number;
}

declare class CountQueuingStrategy implements QueuingStrategy<any> {
    readonly highWaterMark: number;
    constructor({ highWaterMark }: {
        highWaterMark: number;
    });
    size(): 1;
}

declare type TransformStreamDefaultControllerCallback<O> = (controller: TransformStreamDefaultController<O>) => void | PromiseLike<void>;
declare type TransformStreamDefaultControllerTransformCallback<I, O> = (chunk: I, controller: TransformStreamDefaultController<O>) => void | PromiseLike<void>;
interface Transformer<I = any, O = any> {
    start?: TransformStreamDefaultControllerCallback<O>;
    transform?: TransformStreamDefaultControllerTransformCallback<I, O>;
    flush?: TransformStreamDefaultControllerCallback<O>;
    readableType?: undefined;
    writableType?: undefined;
}
declare class TransformStream<I = any, O = any> {
    constructor(transformer?: Transformer<I, O>, writableStrategy?: QueuingStrategy<I>, readableStrategy?: QueuingStrategy<O>);
    readonly readable: ReadableStream<O>;
    readonly writable: WritableStream<I>;
}
declare type TransformStreamDefaultControllerType<O> = TransformStreamDefaultController<O>;
declare class TransformStreamDefaultController<O> {
    readonly desiredSize: number | null;
    enqueue(chunk: O): void;
    error(reason: any): void;
    terminate(): void;
}

export { ReadableStream, UnderlyingSource, UnderlyingByteSource, PipeOptions, ReadResult, ReadableStreamDefaultControllerType as ReadableStreamDefaultController, ReadableByteStreamControllerType as ReadableByteStreamController, ReadableStreamBYOBRequestType as ReadableStreamBYOBRequest, ReadableStreamDefaultReaderType as ReadableStreamDefaultReader, ReadableStreamBYOBReaderType as ReadableStreamBYOBReader, WritableStream, UnderlyingSink, WritableStreamDefaultWriterType as WritableStreamDefaultWriter, WritableStreamDefaultControllerType as WritableStreamDefaultController, QueuingStrategy, ByteLengthQueuingStrategy, CountQueuingStrategy, TransformStream, Transformer, TransformStreamDefaultControllerType as TransformStreamDefaultController };
